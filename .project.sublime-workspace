{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"omp",
				"omp"
			],
			[
				"L",
				"L_C"
			],
			[
				"end",
				"endif"
			],
			[
				"DI",
				"DISABLE_FLAT_CRITERIA"
			],
			[
				"MAX",
				"MAX_MCS_COUNT"
			],
			[
				"over",
				"overlap"
			],
			[
				"g",
				"g_averaged"
			],
			[
				"E",
				"E_min"
			],
			[
				"EM",
				"E_max"
			],
			[
				"E_",
				"E_min"
			],
			[
				"E_m",
				"E_max"
			],
			[
				"prin",
				"println"
			],
			[
				"printS",
				"printStackTrace"
			],
			[
				"Ex",
				"Exception"
			],
			[
				"o",
				"overlap"
			],
			[
				"min",
				"min_hist_index"
			],
			[
				"his",
				"hist"
			],
			[
				"h_co",
				"hi_count"
			],
			[
				"hist",
				"hist2av"
			],
			[
				"hi",
				"histav2"
			],
			[
				"n",
				"n"
			],
			[
				"en",
				"endl"
			],
			[
				"it",
				"it_count_hist"
			],
			[
				"ove",
				"overlap"
			],
			[
				"div",
				"div_averaging"
			],
			[
				"fla",
				"flat_threshold"
			],
			[
				"h",
				"h_delt"
			],
			[
				"it_count_",
				"it_count_g"
			],
			[
				"strin",
				"stringstream"
			],
			[
				"of",
				"ofstream"
			],
			[
				"r",
				"rank"
			],
			[
				"ex",
				"exchange_number"
			],
			[
				"PP",
				"PP_I"
			]
		]
	},
	"buffers":
	[
		{
			"file": "landau-wang-omp-test.cpp",
			"settings":
			{
				"buffer_size": 64947,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n * landau-wang.cpp\n *\n *  Created on: 24 мая 2014 г.\n *      Author: nlare\n * \n *  Данная программа работает не непосредственно с плотностями энергетических состояний, а с энтропией состояний S(E) = ln(G(E))\n */\n\n#include <iostream>\n#include <iomanip>\n#include <cstdlib>\n#include <cmath>\n#include <omp.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <fstream>\n#include <boost/filesystem.hpp>\n#include \"mersenne.cpp\"\n\n#define DEBUG\n#define DEBUG_G\n// #define DEBUG_H_SUM_G_SUM\n// #define E_MIN_E_MAX_OUT\n// #define COUT_IF_HIST_FLAT\n// #define CHECK_H_DELT\n// #define HIST_FLAT_OUT\n#define COUT_EVERY_NUM_STEPS\n// #define REPLICAEXHANGE \n#define energy(b) (2*(b)-2.0*(L*L))\n#define PP_I 4\n#define L 8\n#define DISABLE_FLAT_CRITERIA\n#define MAX_MCS_COUNT 10000\n\n// int neighbour_spins(int,int);\n\nint MakeScriptsForAnimation(std::string);\n\nint main(int argc, char *argv[])  {\n\n    int b, b_new, top_b;    // Текущий энергетический уровень и последующий, top_b - предельный энергетический уровень\n    double f, f_min, ln_f;  /* \"f\" - начальный множитель для энергетических уровней, \n                             * \"f_min\" - минимальное значение множителя\n                             * на каждый принятый шаг f_m = (f_m-1)^1/2\n                             */\n    int skip;                // Количество шагов с неизменной энергией\n    int min_steps;\n    double flat_threshold;   // Порог \"плоскости\" гистограммы\n    double time_b, time_e;  \n    double T;\n    int it_count_g[PP_I],it_count_hist[PP_I];\n    int it_count_av;\n    int global_it_count;\n    int count_mcs;\n    double overlap;\n    int h;\n    int *E_min, *E_max;\n    int *b_last;\n    // int L = 16;\n\n    // int count;\n    double buffer; // Переменная для сохранения g(i) текущей реплики\n    double exchange; // Переменная для сохранения g(i) реплики, с которой происходит обмен\n\n    bool trigger = true;\n    bool convergence_trigger[PP_I];\n    int overlap_interval_begin, overlap_interval_end;\n\n    std::cout << \"adding g_averaged massive\\n\";\n    double g_averaged[4*L*L*L];\n\n    std::cout << \"adding g_normalized massive\\n\";\n    double g_normalized[4*L*L*L];\n\n    std::cout << \"adding hist_averaged massive\\n\";\n    double hist_averaged[4*2*L*L*L];\n\n    CRandomMersenne rg(13617235);\n\n    srand(time(NULL));\n\n    std::ofstream test_g_f, graph_g_f;\n    std::stringstream ss;\n\n    ss.str(\"\");\n    ss << \"test_g\";\n    boost::filesystem::create_directories(ss.str().c_str());\n\n    f = 2.7182818284;  // В работе Ландау-Ванга было указано значение \"f\" равное экспоненте \n    f_min = 1.000001;  // Данная переменная должна быть около единицы\n    min_steps = 10000;\n    skip = 10000;\n    flat_threshold = 0.8;\n    // overlap = 0.75;\n    overlap = 0.95;\n    h = 1;\n\n    it_count_av = 0;\n    count_mcs = 0;\n\n    for(int rank = 0; rank < PP_I; rank++)  {\n\n        it_count_g[rank] = 0;\n        it_count_hist[rank] = 0;\n\n    }  \n\n    double max_in_pp_i, min_in_ge;\n\n    struct _spins   {\n    \n        int spin[L][L][L];\n        bool defect[L][L][L];\n\n    }   system_of[PP_I];\n\n    top_b=L*L*L;\n\n    struct _massive   {\n        \n        double g[4*L*L*L];\n        int hist[4*L*L*L];\n\n    }   massive[PP_I];\n\n    for(int i = 0; i <= 2*L*L*L; i++)    {\n        g_averaged[i] = 0.0;\n    }\n\n    for(int i = 0; i < top_b; i++)  {\n        g_averaged[i] = 0.0;\n        hist_averaged[i] = 0.0;\n    }\n\n    for(int pp_i = 0; pp_i < PP_I; pp_i++)  {\n     \n        for(int i = 0; i < L; i++)    {\n            for(int j = 0; j < L; j++)    {\n            	for(int k = 0; k < L; k++)	 {\n                	system_of[pp_i].spin[i][j][k] = 1;\n				}\n            }\n        }\n\n        // for(int i = 0; i < L; i++)  {\n        //     for(int j = 0;j < L; j++)   {\n        //         if(rg.IRandom(0,10000.0)/10000.0 < 0.5)  \n        //             system_of[pp_i].spin[i][j] = 1;\n        //         else                    \n        //             system_of[pp_i].spin[i][j] = -1;\n        //     }\n        // }\n\n        for(int i = 0; i <= 2*L*L*L; i++)    {\n            massive[pp_i].g[i] = 1.0;\n        }\n\n        for(int i = 0; i <= 2*L*L*L; i++)    {\n            massive[pp_i].hist[i] = 1.0;\n        }\n\n        for(int i = 0; i < L; i++)  {\n            for(int j = 0;j < L; j++)   {\n            	for(int k = 0;k < L; k++)   {\n                // if(rg.IRandom(0,10000.0)/10000.0 < 0.2) system_of[pp_i].defect[i][j] = true;\n                	system_of[pp_i].defect[i][j][k] = false;\n				}\n            }\n        }\n    }\n\n    if(L%2!=0) top_b=2*(L*L*(L-1))+1;\n    else top_b=2*(L*L*L);\n\n    E_min = new int [PP_I];\n    E_max = new int [PP_I];\n\n    b_last = new int [PP_I];\n\n    double value = (top_b - top_b*overlap)/PP_I;\n\n    for(int rank = 1; rank <= PP_I; rank++)   {\n\n        E_min[rank-1] = value*(rank-1);\n        E_max[rank-1] = top_b*overlap + value*rank;\n\n        // if((rg.IRandom(0,1000)/1000) > 0.5) {\n\n            if(E_min[rank-1]%2!=0)   {\n\n                E_min[rank-1] +=1;\n\n            }\n\n            if(E_max[rank-1]%2!=0)  {\n\n                E_max[rank-1] +=1;\n\n            }\n\n        std::cout << std::fixed << std::setprecision(4) << \"E_min[\" << rank-1 << \"]=\" << E_min[rank-1] \\\n                  << \", E_max[\" << rank-1 << \"]=\" << E_max[rank-1] << \", overlap=\" << overlap \\\n                  << std::endl;\n    }    \n\n    for(int i = 0; i < PP_I; i++)   {\n        \n        b_last[i] = E_min[i];  \n        std::cout << \"b_last[\" << i << \"] = \" <<  b_last[i] << std::endl;\n\n    } \n\n    omp_set_num_threads(PP_I);\n\n    time_b = omp_get_wtime();\n\n    std::cout << \"Begin of estimation:\" << std::endl;\n\n    // Считаем пока \"f\" не примет минимальное значение\n    while(f > f_min)    {\n\n        #pragma omp parallel for \\\n        firstprivate(f,min_steps,skip,flat_threshold,h,E_min,E_max,top_b,it_count_g) \\\n        private(b_new,b,ln_f)  \\\n        shared(system_of,massive,b_last,buffer,convergence_trigger,overlap_interval_begin,overlap_interval_end)\n        for(int pp_i = 0; pp_i < PP_I; pp_i++)  {\n        \n        int seed = 1 + rand() % 10000;\n        CRandomMersenne Mersenne(seed);\n        Mersenne.RandomInit(seed);\n\n        int mcs;\n        int count, n;\n        int c = skip+1;\n        double prob;    // Вероятность изменения энергетического уровня\n\n        int L_C = L*overlap;\n\n        if(L_C%2!=0) L_C+=1;\n\n        // #pragma omp critical\n        // std::cout << \"L_C = \" << L_C << std::endl;\n\n        int global_it_count = 0;\n\n        // int E_diff = E_max[pp_i] - E_min[pp_i];\n\n        double g[top_b];\n\n        ln_f = log(f);  // Для вычислений будем использовать логарифм множителя \"f\" \n        count = 1;  // Если гистограмма не стала плоской, останется равной единице и цикл продолжится.\n        mcs = 0;\n        n = 0;\n        // b = 0;\n        #pragma omp flush(b_last)\n        // {\n        b = b_last[pp_i];\n\n        if(b == 0)    {\n            b = E_min[pp_i];\n        }\n\n        int sum_spins = 0;\n\n        std::cout << std::fixed << std::setprecision(8);\n\n        // count_mcs = 0;\n\n        // for(int i = 0; i < L; i++)    {\n        //     for(int j = 0; j < L; j++)    {\n        //         sum_spins += system_of[pp_i].spin[i][j];\n        //     }\n        // }\n\n        // if(omp_get_thread_num()==0)\n        // #pragma omp critical\n        // std::cout << \"b = \" << b << \"\\t, sum_spins = \" << sum_spins << \"\\t, rank = \" << pp_i << std::endl;\n\n        // }\n        // convergence_trigger[pp_i] = false;\n        // b = E_min[pp_i];\n\n        // #pragma omp critical\n        // std::cout << \"chck = \" << b << std::endl;\n\n        // if(omp_get_thread_num() == 1)   {\n        //     #pragma omp flush(massive,E_min,E_max)\n        //     // massive[pp_i].g[20] = massive[0].g[20];\n\n        //     // for(int i = E_min[pp_i]; i < E_max[0];i++)  {\n        //         // massive[pp_i].g[i] = massive[0].g[i];\n        //         // massive[pp_i].hist[i] = massive[0].hist[i];\n        //     // }\n        // }\n\n        // #pragma omp flush(massive)\n        for (int i = 0; i < top_b; i++)   {\n            massive[pp_i].hist[i] = 0;\n        }\n\n        do {\n\n        // if(mcs < 1000)   {\n            // goto m3;\n        // }\n\n        for(int i = 0; i < L; i++)   {\n            for(int j = 0; j < L; j++)  {\n            	for(int k = 0; k < L; k++)  {\n                m1:\n                int ci = Mersenne.IRandom(0, L-1);\n                int cj = Mersenne.IRandom(0, L-1);\n                int ck = Mersenne.IRandom(0, L-1);\n\n                // if(system_of[pp_i].defect[ci][cj] == false) goto m1;  // Исключаем немагнитные спины\n\n                int neighbour_spins = 0;\n                #pragma omp flush(system_of)\n                if(ci==0)   neighbour_spins=system_of[pp_i].spin[L-1][cj][ck];\n                else        neighbour_spins=system_of[pp_i].spin[ci-1][cj][ck];\n                if(ci==L-1) neighbour_spins+=system_of[pp_i].spin[0][cj][ck];\n                else        neighbour_spins+=system_of[pp_i].spin[ci+1][cj][ck];\n                if(cj==0)   neighbour_spins+=system_of[pp_i].spin[ci][L-1][ck];\n                else        neighbour_spins+=system_of[pp_i].spin[ci][cj-1][ck];\n                if(cj==L-1) neighbour_spins+=system_of[pp_i].spin[ci][0][ck];\n                else        neighbour_spins+=system_of[pp_i].spin[ci][cj+1][ck];\n                if(ck==0)   neighbour_spins+=system_of[pp_i].spin[ci][cj][L-1];\n                else        neighbour_spins+=system_of[pp_i].spin[ci][cj][ck-1];\n                if(ck==L-1) neighbour_spins+=system_of[pp_i].spin[ci][cj][0];\n                else        neighbour_spins+=system_of[pp_i].spin[ci][cj][ck+1];\n\n                // #pragma omp flush(system_of)\n                b_new = b + system_of[pp_i].spin[ci][cj][ck]*neighbour_spins;   // Считаем новое состояние\n\n                // std::cout << \"b_new = \" << b_new << std::endl;\n                // #pragma omp critical\n                // std::cout << \"[\" << omp_get_thread_num() << \"]\" << std::endl;\n                // {\n                    // if(omp_get_thread_num() == 1)\n                    // std::cout << E_max[pp_i] << std::endl;\n                    // std::cout << b_new << std::endl; \n                // }\n                // #pragma omp flush\n                // {\n\n                #pragma omp flush(E_min, E_max)\n                if((b_new < E_max[pp_i]) && (b_new > E_min[pp_i] && system_of[pp_i].defect[i][j][k] == false))   {   // Если энергия в допустимых пределах\n\n                    prob = exp(massive[pp_i].g[b]-massive[pp_i].g[b_new]);  // Вероятность принятия нового энергетического состояния\n                    // prob = massive[pp_i].g[b]/massive[pp_i].g[b_new];\n                    // #pragma omp critical\n                    // if(omp_get_thread_num() == 1)\n                    // std::cout << prob << \"\\n\";\n                    if(prob >= 1.0 || (double)(Mersenne.IRandom(1,10000)/10000.0) < prob)    {\n\n                        b = b_new;\n                        // #pragma omp flush(system_of)\n                        // #pragma omp critical\n                        system_of[pp_i].spin[ci][cj][ck] *= -1;\n\n                    }\n                    \n                    massive[pp_i].g[b] += ln_f;   // Увеличиваем текущий энергетический уровень на логарифм \"f\"\n                    // massive[pp_i].g[b]*=f;\n                    massive[pp_i].hist[b] += 1;\n                    // #pragma omp critical\n                    // if(omp_get_thread_num() == 1)\n                    // {\n                    //     std::cout << \"RUN IN ONE!\" << std::endl;\n                        // std::cout << \"massive[\" << pp_i << \"].g[\" << b << \"]=\" << massive[pp_i].g[b] << std::endl;\n                    // }\n                    n++;\n                }\n              }\n           }\n        }\n\n        // count++;\n\n        #pragma omp critical \n        {\n        // Если первая итерация и mcs делится на 100 без остатка, то \n        if(f == 2.7182818284 && mcs%100000 == 0)   {\n        // if(omp_get_thread_num() == 0 && ln_f == 1)  {\n\n                // std::cout << \"IN!\" << std::endl;\n                count_mcs++;\n                // std::cout << \"C = \" << count_mcs << std::endl;\n\n                for(int pp_i = 0; pp_i < PP_I; pp_i++)  {\n\n                // int first_not_null_g;\n                // int number_of_iteration;\n                // double min_g_value;\n        \n                it_count_hist[pp_i]++;\n\n                ss.str(\"\");\n                ss << \"test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-\" << pp_i;\n                boost::filesystem::create_directories(ss.str().c_str());\n\n                ss << \"/\" << it_count_hist[pp_i] << \".dat\";\n                // std::cout << \"write to \" << ss.str() << std::endl;\n    \n                test_g_f.open(ss.str().c_str());\n    \n                for(int i = E_min[pp_i]; i < E_max[pp_i]; i++)  {\n                    if((i!=2*E_max[pp_i]-1) && i%2)    {\n                        // test_g_f << std::fixed << std::setprecision(6) << i << \"\\t\" << energy(i) << \"\\t\" << massive[pp_i].g[i] << \"\\n\";\n                        test_g_f << std::fixed << std::setprecision(6) << i << \"\\t\" << energy(i) << \"\\t\" << massive[pp_i].hist[i] << \"\\n\";\n                        // std::cout << \"massive.g[\" << i << \"]=\" << massive[pp_i].g[i] << std::endl;\n                    }\n                }\n    \n                test_g_f.close();\n    \n                ss.str(\"\");\n                ss << \"test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-\" << pp_i << \"/temp\";\n                boost::filesystem::create_directories(ss.str().c_str());\n    \n                ss.str(\"\");\n                ss << \"test_g/Hist-\" << \"L=\" << L << \"_PP=\" << PP_I << \"-\" << pp_i << \"/temp/\" << it_count_hist[pp_i] << \".plot\";\n                graph_g_f.open(ss.str().c_str());\n    \n                ss.str(\"\");\n                ss << \"test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-\" << pp_i << \"/graphs\";\n                boost::filesystem::create_directories(ss.str().c_str());\n    \n                ss.str(\"\");\n                ss << \"test_g/Hist-\" << \"L=\" << L << \"_PP=\" << PP_I << \"-\" << pp_i << \"/\" << it_count_hist[pp_i] << \".dat\";\n    \n                graph_g_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                         \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                         \"set output \\\"test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-\" << pp_i << \"/graphs/\" << it_count_hist[pp_i] << \".jpg\\\"\\n\" << \\\n                         \"set grid x y\\n\" << \\\n                         \"set xtics 10 \\n\" << \\\n                         \"set ytics 2000 \\n\" << \\\n                         \"set mxtics 10 \\n\" << \\\n                         \"set mytics 10  \\n\" << \\\n                         \"set xrange [\" << E_min[pp_i] << \":\" << E_max[pp_i] << \"]\\n\" << \\\n                         \"set yrange [0:20000]\\n\" << \\\n                         \"set xlabel \\\"i [\" << E_min[pp_i] << \":\" << E_max[pp_i] << \"]\" << \"\\\"\\n\" << \\\n                         \"set ylabel \\\"Hist(i)\\\"\\n\" << \\\n                         \"plot \\\"\" << ss.str() << \"\\\" using 1:3 title \\\"landau-wang-\" << L << \"-iteration-\" << it_count_hist[pp_i] << \"\\\" with lines lt rgb \\\"red\\\"\";\n    \n                graph_g_f.close();\n\n            }\n\n        // }\n\n        }\n\n        }\n\n        // m3:\n\n        mcs++;\n        c++;\n\n        // #pragma omp critical\n        // {\n        //     std::cout << \"mcs[\" << pp_i << \"]:\" << mcs << std::endl;\n        // }\n\n        #pragma omp flush(massive, E_min, E_max)\n        // if(mcs == 5000 && pp_i == 0 && ln_f == 1)    {\n        //     std::cout << \"in cycle!\\n\";\n        //     for(int i = E_min[pp_i]; i < E_max[pp_i]; i++)  {\n\n        //         massive[pp_i+1].hist[i] = massive[pp_i].hist[i];\n\n        //     }\n\n        // }\n        \n        if((mcs >= min_steps) && (c >= skip))    {\n\n            // int diff_between_g;\n            \n            c = 0;\n\n        // #pragma omp critical\n        // {\n        //     std::cout << \"flat_threshold = \" << flat_threshold << std::endl; \n        // }\n        \n            #ifdef DEBUG\n            // std::cout << \"In count area. \\n\";\n            // std::cout << \"mcs = \" << mcs << std::endl;\n            #endif\n\n            int num_of_exchange_replica;\n            // int overlap_interval_begin, overlap_interval_end;\n            int random_index_x, random_index_y;\n\n            overlap_interval_begin = 0;\n            overlap_interval_end = 0;\n\n            #pragma omp critical\n            {\n            // Зададим граничные условия\n            if(pp_i == 0)   {\n\n                // std::cout << \"\\nIN SECTION!\";\n                num_of_exchange_replica = pp_i+1;\n                // std::cout << \"\\nnum_of_exchange_replica = \" << num_of_exchange_replica;\n\n            }   else    {\n\n                if(pp_i == PP_I-1)   {\n                \n                    num_of_exchange_replica = pp_i-1;\n\n                }   else {\n\n                    if(Mersenne.IRandomX(1,10000)/10000.0 > 0.5) num_of_exchange_replica = pp_i+1;\n                    else num_of_exchange_replica = pp_i-1;\n\n                }\n\n            }\n\n            if(pp_i < num_of_exchange_replica)  {\n\n                overlap_interval_begin = E_min[num_of_exchange_replica];\n                overlap_interval_end = E_max[pp_i];\n\n            }   else    {\n            \n                overlap_interval_begin = E_min[pp_i];\n                overlap_interval_end = E_max[num_of_exchange_replica];\n\n            }\n\n            }\n\n            // std::cout << \"overlap_interval_begin = \" << overlap_interval_begin << \"; overlap_interval_end = \" << overlap_interval_end << std::endl;\n\n            // #pragma omp flush(E_min)\n            // diff_between_g = E_min[pp_i] - E_min[num_of_exchange_replica];\n            // std::cout << \"dbg = \" << diff_between_g << std::endl;\n\n            // overlap_interval_begin -= 2; \n            // overlap_interval_end -= 1; \n\n            // #ifdef DEBUG\n            // if(pp_i == 1)   {\n                // std::cout << pp_i << \":overlap_interval_begin=\" << overlap_interval_begin << std::endl;\n                // std::cout << pp_i << \":overlap_interval_end=\" << overlap_interval_end << std::endl;\n            // }\n            // #endif\n\n            // prob = 0.01;\n            // count = 0;\n\n            #pragma omp flush(E_min, E_max)\n\n            // int first_not_null_g_for_pp_i, first_not_null_g_for_exchange_replica; \n            // double delta_G = 0.0;\n            #ifdef REPLICAEXHANGE\n            #pragma omp critical\n            {           \n                // for(int i = overlap_interval_begin; i < overlap_interval_end; i++)\n                // for(int exchange_number = 0; exchange_number < (overlap_interval_end - overlap_interval_begin)/2; exchange_number++)\n                {\n\n                // for(int i = overlap_interval_begin; i < overlap_interval_end; i+=2)  {\n\n                    // random_index_y = random_index_x - diff_between_g;\n\n                    // if(random_index_x%2!=0)\n                    // std::cout << \"random_index_x = \" << random_index_x << std::endl;\n                    // std::cout << \"random_index_y = \" << random_index_y << std::endl;\n\n                    #pragma omp flush(massive)\n                    // if(convergence_trigger[num_of_exchange_replica]==false)\n                    // if(massive[pp_i].hist[random_index_x] != 0 && massive[num_of_exchange_replica].hist[random_index_y] != 0)\n                \n                    // for(int exchange_number = 0; exchange_number < (overlap_interval_end - overlap_interval_begin)/2; exchange_number++)\n                    {\n\n                    // while(random_index_y%2!=0)  {\n                    //     random_index_y = Mersenne.IRandom(0,top_b);\n                    //     if(random_index_y%2==0) break;\n                    // }\n\n                    for(int exchange_number = 0; exchange_number < (overlap_interval_end - overlap_interval_begin)/2; exchange_number++)\n                    {\n\n                    random_index_x = Mersenne.IRandom(0,top_b);\n                    // random_index_y = Mersenne.IRandom(0,top_b);\n                    // random_index_y = random_index_x;\n\n                    while(random_index_x%2!=0)  {\n                        random_index_x = Mersenne.IRandom(0,top_b);\n                        if(random_index_x%2==0) break;\n                    }\n\n                    random_index_y = random_index_x;\n\n                    if((random_index_x > overlap_interval_begin+2) && (random_index_x < overlap_interval_end)\\\n                        && (random_index_y > overlap_interval_begin+2) && (random_index_y < overlap_interval_end))    {\n\n                        // if(massive[pp_i].hist[random_index_x]!=0 && massive[pp_i].hist[random_index_x]!=0 \\\n                            // && massive[num_of_exchange_replica].hist[random_index_y]!=0 && massive[num_of_exchange_replica].hist[random_index_y]!=0)\n                        #pragma omp flush(random_index_x,random_index_y)\n                        // {\n                            prob = (massive[pp_i].g[random_index_x]*massive[num_of_exchange_replica].g[random_index_y])/ \\\n                                   (massive[pp_i].g[random_index_y]*massive[num_of_exchange_replica].g[random_index_x]);\n\n\n                        if(prob >= 1.0 || (double)(Mersenne.IRandom(1,10000)/10000.0) < prob) { //&& (fabs(massive[pp_i].g[random_index_y] - massive[num_of_exchange_replica].g[random_index_y])) < 100.0) {\n\n                            // ---------------- EXHANGE BETWEEN SOME RANDOM INDEXES OF G[i] -----------------------\n\n                            // if(abs(massive[pp_i].g[random_index_x] - massive[num_of_exchange_replica].g[random_index_y]) < 100.0)    {\n                                \n                                // std::cout << \"init exchange between THREAD #\" << pp_i << \" and #\" << num_of_exchange_replica << \" : \" << random_index_x << \"[\" << massive[pp_i].g[random_index_x] << \"]\" << \" <-> \" << random_index_y << \"[\" << massive[num_of_exchange_replica].g[random_index_y] << \"]\" << std::endl;\n                                // #pragma omp flush(massive,buffer,random_index_x,random_index_y,ln_f)\n\n                                double buffer = massive[pp_i].g[random_index_x];\n                                massive[pp_i].g[random_index_x] = massive[num_of_exchange_replica].g[random_index_x];\n                                massive[num_of_exchange_replica].g[random_index_x] = buffer;\n\n                                buffer = massive[pp_i].g[random_index_y];\n                                massive[pp_i].g[random_index_y] = massive[num_of_exchange_replica].g[random_index_y];\n                                massive[num_of_exchange_replica].g[random_index_y] = buffer;\n\n                                // if()\n\n                                massive[pp_i].g[random_index_x] += ln_f;\n                                massive[pp_i].hist[random_index_x] += 1;                                \n\n                                massive[pp_i].g[random_index_y] += ln_f;\n                                massive[pp_i].hist[random_index_y] += 1;                                \n\n                                massive[num_of_exchange_replica].g[random_index_x] += ln_f;\n                                massive[num_of_exchange_replica].hist[random_index_x] += 1;\n\n                                massive[num_of_exchange_replica].g[random_index_y] += ln_f;\n                                massive[num_of_exchange_replica].hist[random_index_y] += 1;\n        \n                        }   \n                        \n                    }\n\n                    }\n                    \n                    }                    \n\n                }\n            }\n\n            #endif\n\n            int h_count = 0;\n            double h_delt = 0.0;\n            double h_sum = 0.0;\n\n            h_delt = 0.0;\n\n            // #pragma omp critical\n\n            // #pragma omp critical\n            {\n\n            // Старый вариант проверки на плоскость гистограммы\n            // ---------------------------------\n            // for(int i = E_min[pp_i]; i < E_max[pp_i]; i++) {\n\n            //     // if(massive[pp_i].hist[i] != 0)    {\n            //     if(i%2 == 0)    {\n\n            //         h_sum += (double)massive[pp_i].hist[i]/min_steps;\n            //         h_count++;\n\n            //     }\n\n            // }\n\n            // // #pragma omp flush\n            // count = 0;  // Выходим из цикла по окончанию\n\n            // for (int i = E_min[pp_i]; i < E_max[pp_i]; i++)    {\n            //     if(massive[pp_i].hist[i] != 0)    {\n            //         h_delt = (massive[pp_i].hist[i]/(h_sum/h_count))/min_steps;\n            //         if((h_delt < flat_threshold) || (h_delt > 1+flat_threshold)) count =1;\n            //         // else count = 0;\n\n            //         // if(h_delt < flat_threshold) {\n            //         //     std::cout << std::endl << \"---------------------------\" << std::endl;\n            //         //     std::cout << i << \":\" << h_delt << std::endl;\n            //         //     std::cout << \"---------------------------\" << std::endl;\n            //         // }\n\n            //         // else goto m2;\n            //     //     if((massive[pp_i].g[i] < E_max[pp_i]) && (massive[pp_i].g[i] > E_max[pp_i]-4 ) ) {\n            //     //     std::cout << i << \":\" << h_delt << std::endl;\n            //     // }\n            //     }\n            // }\n\n            // ---------------------------------\n\n            // Новый вариант проверки на плоскость гистограммы основанный на среднеквадратичном отклонении\n            // ---------------------------------\n            #ifndef DISABLE_FLAT_CRITERIA\n            {\n                #pragma omp flush(massive)\n\n                long double histav2 = 0.0; // Квадрат суммы\n                long double hist2av = 0.0; // Сумма квадратов\n                long double delta = 0.0;\n\n                double min_hist = 0.0;\n                int min_hist_index = 0;\n\n                int hi_count = 0;\n\n                count = 0;\n\n                min_hist_index = (E_min[pp_i] + E_max[pp_i])/2;\n\n                if(min_hist_index%2 != 0) min_hist_index += 1;\n\n                min_hist = massive[pp_i].hist[min_hist_index];\n\n                for(int i = E_min[pp_i]; i < E_max[pp_i]; i++)  {\n                    \n                    if(i%2 == 0 && min_hist > massive[pp_i].hist[i] && massive[pp_i].hist[i] > 0)    {\n\n                        min_hist = massive[pp_i].hist[i];\n\n                    }\n\n                }\n\n                #pragma omp flush(massive)\n                // std::cout << \"min_hist = \" << min_hist << std::endl;\n\n                for(int i = E_min[pp_i]; i < E_max[pp_i]; i++)  {\n\n                    if((i > 4) && (i%2 == 0) && (massive[pp_i].hist[i] > 0))   {\n\n                        // histav2 += (massive[pp_i].hist[i] - min_hist);\n                        histav2 += (massive[pp_i].hist[i]);\n                        // std::cout << pp_i << \": hist[\" << i << \"]=\" << massive[pp_i].hist[i] - min_hist << std::endl;\n                        // hist2av += (massive[pp_i].hist[i] - min_hist)*(massive[pp_i].hist[i] - min_hist);\n                        hist2av += (massive[pp_i].hist[i])*(massive[pp_i].hist[i]);\n\n                        hi_count++;\n\n                    }\n\n                }\n\n                // hist2av = abs(hist2av);\n                histav2 = histav2/hi_count;\n\n                delta = hist2av - histav2*histav2;\n                delta = powf(delta, 0.5);\n                // delta = delta/min_steps;\n\n                // if(delta > 1+flat_threshold || delta < 1-flat_threshold) count = 1;\n                if(delta > flat_threshold) count = 1;\n            }\n            #endif\n\n                if(mcs >= MAX_MCS_COUNT) count = 0;\n                // else count = 1;\n                #ifdef HIST_FLAT_OUT\n                std::cout << \"hist2av = \" << hist2av << \"; histav2 = \" << histav2 << \"; hi_count = \" << hi_count << \"; delta = \" << delta << std::endl;\n                #endif\n\n            // ---------------------------------\n\n            }\n\n            // #pragma omp flush\n            // if(count == 1 && h_delt > flat_threshold) goto m2;\n            // printf(\"h_delt = %f\\n\",h_delt);\n            #pragma omp critical\n            {\n\n            #ifdef CHECK_H_DELT\n                std::cout << std::setprecision(8) << \"f=\" << f << \", ln_f=\" << ln_f << \", flat_threshold = \" << flat_threshold << \", h_delt = \" << h_delt << \", count = \" << count << \", PP = \" << pp_i << std::endl;\n            #endif\n\n            #ifdef COUT_EVERY_NUM_STEPS\n                std::cout << \"L = \" << L << \": f = \" << f << \", ln_f = \" << ln_f << \"; PP = \" << PP_I << \"; thread = \" << pp_i << \": mcs = \" << mcs << std::endl; \n            #endif\n\n            }\n            // Убрать, если все будет хорошо считаться\n            // if(mcs > 100000) goto m2;\n        \n        }   else count = 1;\n\n        }   while(count);\n\n        m2:\n\n        #pragma omp critical\n\n        #ifdef COUT_IF_HIST_FLAT\n        std::cout << \"Histogram is FLAT for relica #\" << pp_i << std::endl;\n        #endif\n\n        if(omp_get_thread_num() == 0)    {\n\n        for(int rank = 0; rank < PP_I; rank++)  {\n\n        int first_not_null_g;\n        double min_g_value;\n        \n        it_count_g[rank]++;\n        // std::cout << \"it[\" << rank << \"]=\" << it_count_g[rank] << std::endl;\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-\" << pp_i;\n        boost::filesystem::create_directories(ss.str().c_str());\n\n        ss << \"/\" << it_count_g[rank] << \".dat\";\n        // std::cout << \"write to \" << ss.str() << std::endl;\n\n        test_g_f.open(ss.str().c_str());\n\n        for(int i = E_min[rank]; i < E_max[rank]; i++)  {\n            // if((i!=2*E_max[pp_i]-1) && (massive[pp_i].hist[i] != 0))    {\n            if((i!=2*E_max[rank]-1) && (i%2 != 0))    {\n            // if(((i!=2*E_max[pp_i]-1) && i%2 == 0) || i == 0)    {\n                // test_g_f << std::fixed << std::setprecision(6) << i << \"\\t\" << energy(i) << \"\\t\" << massive[pp_i].g[i] << \"\\n\";\n                test_g_f << std::fixed << std::setprecision(6) << i << \"\\t\" << energy(i) << \"\\t\" << massive[rank].g[i] << \"\\n\";\n                // std::cout << \"massive.g[\" << i << \"]=\" << massive[pp_i].g[i] << std::endl;\n            }\n        }\n\n        test_g_f.close();\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-\" << rank << \"/temp\";\n        boost::filesystem::create_directories(ss.str().c_str());\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-\" << \"L=\" << L << \"_PP=\" << PP_I << \"-\" << rank << \"/temp/\" << it_count_g[rank] << \".plot\";\n        graph_g_f.open(ss.str().c_str());\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-\" << rank << \"/graphs\";\n        boost::filesystem::create_directories(ss.str().c_str());\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-\" << \"L=\" << L << \"_PP=\" << PP_I << \"-\" << rank << \"/\" << it_count_g[rank] << \".dat\";\n\n        graph_g_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-\" << rank << \"/graphs/\" << it_count_g[rank] << \".jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xtics 20 \\n\" << \\\n                 \"set ytics 1000 \\n\" << \\\n                 \"set mxtics 5 \\n\" << \\\n                 \"set mytics 5  \\n\" << \\\n                 \"set xrange [\" << E_min[rank] << \":\" << E_max[rank] << \"]\\n\" << \\\n                 \"set xlabel \\\"i [\" << E_min[rank] << \":\" << E_max[rank] << \"]\" << \"\\\"\\n\" << \\\n                 \"set ylabel \\\"G(i)\\\"\\n\" << \\\n                 \"plot \\\"\" << ss.str() << \"\\\" using 1:3 title \\\"landau-wang-\" << L << \"-iteration-\" << it_count_g[rank] << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n        graph_g_f.close();\n\n        }\n\n        }\n\n        b_last[pp_i] = b;\n        // std::cout << \"b_last[\" << pp_i << \"]= \" << b_last[pp_i] << std::endl;\n        // convergence_trigger[pp_i] = true;\n\n        for(int i = 0; i < top_b; i++)  {\n\n            massive[pp_i].hist[i] = 0.0;\n\n        }\n\n        // #pragma omp critical\n        // std::cout << \"-----------------------------\\n\";\n        // std::cout << \"#\" << pp_i << \": mcs = \" << mcs << \" IS FLAT\" << std::endl; \n        // std::cout << \"-----------------------------\\n\";\n\n        }\n\n        // #pragma omp barrier\n\n        // Процедура усреднения и перераспределения между репликами среднего значения плотности энергетических состояний\n\n        #pragma omp flush(massive,hist_averaged,g_averaged)\n\n        if(omp_get_thread_num() == 0)   {\n\n        int div_averaging[top_b];\n\n        // for(int i = 0; i < overlap_interval_begin+4; i++) {\n        //     div_averaging[i] = 1;\n        //     // g_averaged[i] -= 1;\n        // }\n\n        // for(int i = overlap_interval_begin+4; i < overlap_interval_end; i++) {\n        //     div_averaging[i] = 2;\n        //     // g_averaged[i] -= 1;\n        // }\n\n        // for(int i = overlap_interval_end; i < top_b; i++) {\n        //     div_averaging[i] = 1;\n        //     // g_averaged[i] -= 1;\n        // }\n\n        // std::cout << \"TEST1!\\n\";\n        // for(int )\n\n        for(int i = 0; i < top_b; i++)  {\n            if(PP_I == 2) div_averaging[i] = PP_I;\n            if(PP_I >= 4) div_averaging[i] = 0;\n        }\n\n        div_averaging[0] = 1;\n        div_averaging[2] = 1;\n        div_averaging[4] = 1;\n\n        for(int i = 0; i < 2*top_b; i++)    {\n            g_averaged[i] = 1.0;\n            hist_averaged[i] = 0.0;\n        }\n\n        // std::cout << \"TEST2!\\n\";\n\n        // std::cout << \"overlap_interval_begin = \" << overlap_interval_begin << \"; overlap_interval_end = \" << overlap_interval_end << std::endl;\n        #pragma omp flush(massive, E_min, E_max)\n\n        for(int i = 0; i < top_b; i++)  {\n\n            #ifdef DEBUG_H_SUM_G_SUM\n            std::cout << \"------------------------------------------------------------------\" << std::endl;\n            #endif\n\n            max_in_pp_i = 0;   \n            for(int rank = 0; rank < PP_I; rank++)  {\n                 // if(massive[pp_i].hist[i]!=0) \n                 if(i%2 == 0 || i == 0)  \n                 {\n                    // -------------- CHOOSE MAX G[E] IN ALL REPLICAS -----------------\n                    // if(massive[pp_i].g[i] > max_in_pp_i)   {    \n                    //     max_in_pp_i = massive[pp_i].g[i];\n                    //     g_averaged[i] = max_in_pp_i;\n                    // }\n                    // -------------- CHOOSE MAX G[E] IN ALL REPLICAS -----------------\n    \n                    // -------------- AVERAGING ALL REPLICAS G[E] -----------------\n\n                    hist_averaged[i] = hist_averaged[i] + massive[rank].hist[i];\n                    // std::cout << \"----------------------------------------------\" << std::endl;\n\n                    // hist_averaged[i] = 1.0;\n\n                    // g_averaged[i] += massive[pp_i].g[i];\n\n                    /*\n                     * Only for L = 8\n                     * \n                     */\n                    if(PP_I == 2)   {\n                        \n                        if(rank == 0)   {   \n\n                            if(i <= overlap_interval_begin+4)    {\n\n                                g_averaged[i] = massive[rank].g[i];\n\n                            }\n\n                            if((i > overlap_interval_begin+4) && i < overlap_interval_end)    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 1)   {\n\n                            if(i >= overlap_interval_end)    {\n\n                                g_averaged[i] = massive[rank].g[i]; \n\n                            }\n\n                            if((i > overlap_interval_begin+4) && i < overlap_interval_end)    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                    }\n\n                    if(PP_I == 4)   {\n                        \n                        if((i > E_min[rank]+4) && (i < E_max[rank]))    {\n\n                            div_averaging[i]++;\n\n                            // g_averaged[i] = g_averaged[i] + massive[rank].g[i];\n\n                        }\n\n                        if(rank == 0)   {\n\n                            if((i > E_min[rank]+4) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 1)   {\n\n                            if((i > E_min[rank]+4) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 2)   {\n\n                            if((i > E_min[rank]+4) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 3)   {\n\n                            if((i > E_min[rank]+4) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                    }\n\n                    if(PP_I == 8)   {\n                        \n                        if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                            div_averaging[i]++;\n\n                            // g_averaged[i] = g_averaged[i] + massive[rank].g[i];\n\n                        }\n\n                        if(rank == 0)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 1)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 2)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 3)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 4)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 5)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 6)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 7)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }                                                                        \n\n                    }\n\n                    if(PP_I == 16)   {\n                        \n                        if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                            div_averaging[i]++;\n\n                            // g_averaged[i] = g_averaged[i] + massive[rank].g[i];\n\n                        }\n\n                        if(rank == 0)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 1)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 2)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 3)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 4)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 5)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 6)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 7)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }    \n\n                        if(rank == 8)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 9)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 10)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 11)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 12)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 13)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 14)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n                        if(rank == 15)   {\n\n                            if((i > E_min[rank]+2) && (i < E_max[rank]))    {\n\n                                g_averaged[i] = g_averaged[i] + massive[rank].g[i]; \n\n                            }\n\n                        }\n\n\n                    }\n\n\n                    // g_averaged[i] = g_averaged[i] + massive[rank].g[i];\n\n\n                    // -------------- AVERAGING ALL REPLICAS G[E] ----------------\n                    // if(f == 2.7182818284)    \n\n                    if(i > overlap_interval_begin+2 && i < overlap_interval_end)  {\n\n\n                        // ...\n                    }   else    {\n\n                        // g_averaged[i] -= 1;\n                        if(PP_I == 2) div_averaging[i] = 1;\n\n                    }\n                }\n\n                #ifdef DEBUG_H_SUM_G_SUM\n                std::cout << \"pp_i = \" << rank << \": i: \" << i << \": H_SUM=\" << hist_averaged[i] << \", H[\" << rank << \"]=\" << (double) massive[rank].hist[i] \\\n                              << \", G_SUM=\" << g_averaged[i] << \", G[\" << rank << \"]=\" << massive[rank].g[i] << std::endl;\n                #endif\n\n                #ifdef E_MIN_E_MAX_OUT\n                std::cout << \"E_min[\" << 0 << \"]=\" << E_min[0] << std::endl; \n                std::cout << \"E_min[\" << 1 << \"]=\" << E_min[1] << std::endl; \n                std::cout << \"E_max[\" << 0 << \"]=\" << E_max[0] << std::endl; \n                std::cout << \"E_max[\" << 1 << \"]=\" << E_max[1] << std::endl; \n                #endif\n            }   \n        }\n\n        std::cout << std::endl;\n\n        int count = 0;\n\n        #pragma omp flush(massive)\n\n        // if(omp_get_thread_num() == 0)   {\n            // std::cout << \"Check1: g_averaged = \" << g_averaged[0] << std::endl;\n        // }\n\n        for(int rank = 0; rank < PP_I; rank++)     {\n\n        #ifdef E_MIN_E_MAX_OUT  \n        {\n            std::cout << \"E_min[\" << rank << \"]=\" << E_min[rank] << \"; E_max[\" << rank << \"]=\" << E_max[rank] << std::endl;\n            std::cout << std::endl;\n        }\n        #endif\n\n        }\n\n        for(int i = 0; i < top_b; i++)     {\n\n            if(i%2 == 0 || i == 0)  {\n\n                count++;\n                g_averaged[i]/=div_averaging[i];\n                hist_averaged[i]/=div_averaging[i];\n\n                // #define DEBUG_G\n                #ifdef DEBUG_G\n                if(PP_I >= 4)   {\n\n                    std::cout << \"G0[\" << i << \"]=\" << massive[0].g[i] \\\n                          << \" :: G1[\" << i << \"]=\" << massive[1].g[i] << \":: G2[\" << i << \"]=\" << massive[2].g[i] \\\n                          << \":: G3[\" << i << \"]=\" << massive[3].g[i] << \":: G_AV[\" << i << \"]=\" << g_averaged[i] \\\n                          << \" :: DIV:\" << div_averaging[i] << \" :: Count = \" << count << std::endl;\n\n                }\n\n                if(PP_I == 2)   {\n\n                    std::cout << \"G0[\" << i << \"]=\" << massive[0].g[i] \\\n                          << \" :: G1[\" << i << \"]=\" << massive[1].g[i] \\\n                          << \":: G_AV[\" << i << \"]=\" << g_averaged[i]  \\\n                          << \" :: DIV:\" << div_averaging[i] << \" :: Count = \" << count << std::endl;                    \n\n                }\n                #endif \n\n            }\n        }\n\n        if(f == 2.7182818284)    {\n\n        // for(int pp_i = 0; pp_i < PP_I; pp_i++)  {\n\n        int first_not_null_g;\n        double min_g_value;\n        \n        it_count_av++;\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-AV\";\n        boost::filesystem::create_directories(ss.str().c_str());\n\n        ss << \"/\" << it_count_av << \".dat\";\n        // std::cout << \"write to \" << ss.str() << std::endl;\n\n        test_g_f.open(ss.str().c_str());\n\n        for(int i = 0; i < top_b; i++)  {\n            // if((i!=2*top_b-1) && (hist_averaged[i] != 0))    {\n            if(((i!=2*top_b-1) && (i%2 == 0)) || i == 0)    {\n                test_g_f << std::fixed << std::setprecision(6) << i << \"\\t\" << energy(i) << \"\\t\" << g_averaged[i] << \"\\n\";\n                // std::cout << \"massive.g[\" << i << \"]=\" << massive[pp_i].g[i] << std::endl;\n            }\n        }\n\n        test_g_f.close();\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \"/temp\";\n        boost::filesystem::create_directories(ss.str().c_str());\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-\" << \"L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \"/temp/\" << it_count_av << \".plot\";\n        graph_g_f.open(ss.str().c_str());\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \"/graphs\";\n        boost::filesystem::create_directories(ss.str().c_str());\n\n        ss.str(\"\");\n        ss << \"test_g/DoS-\" << \"L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \"/\" << it_count_av << \".dat\";\n\n        graph_g_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \"/graphs/\" << it_count_av << \".jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xlabel \\\"i\\\"\\n\" << \\\n                 \"set ylabel \\\"G(i)\\\"\\n\" << \\\n                 \"plot \\\"\" << ss.str() << \"\\\" using 1:3 title \\\"landau-wang-\" << L << \"-iteration-\" << it_count_av << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n        graph_g_f.close();\n\n        // }\n\n        }\n\n        // std::cout << \"Check2\" << std::endl;   \n\n        #pragma omp flush(massive, g_averaged)\n\n        for(int rank = 0; rank < PP_I; rank++)  {\n            for(int i = 0; i < top_b; i++)  {\n    \n                massive[rank].g[i] = g_averaged[i];\n                massive[rank].hist[i] = 0;\n                hist_averaged[i] = 0;\n\n                // if(i%2==0) massive[rank].hist[i] = 1.0;\n    \n            }\n        }\n\n        }\n\n        #pragma omp barrier\n        \n        // if(omp_get_thread_num() == 0)   {\n            // massive[0].g[0] = 0.0;\n            // g_averaged[0] = 0.0;\n        // }\n        \n        #pragma omp flush(massive)\n\n        f = pow(f, 0.5);    // Изменяем множитель\n\n    }   // while (f > f_min) cycle \n\n    std::cout << \"Ending estimation of G.\" << std::endl;\n    std::cout << \"Begin Normalising of G:\" << std::endl;\n\n    // std::cout << \"Thread #\" << omp_get_thread_num() << std::endl;\n\n    #pragma omp flush(massive)\n\n    min_in_ge = g_averaged[4]; // index may be anything (not L*L)\n\n    for(int i = 0; i < top_b; i++)  {\n        // if(hist_averaged[i]!=0)  {\n        if(i%2 == 0 && i >= 4 && g_averaged[i] != 1.0)  {\n            if(g_averaged[i] < min_in_ge)\n            min_in_ge = g_averaged[i];\n        }\n    }\n\n    g_averaged[top_b] = min_in_ge;\n\n    if(PP_I == 2)    {\n\n        massive[0].g[top_b] = g_averaged[top_b];\n        massive[1].g[top_b] = g_averaged[top_b];\n\n    }\n\n    if(PP_I == 4)    {\n\n        massive[0].g[top_b] = g_averaged[top_b];\n        massive[1].g[top_b] = g_averaged[top_b];\n        massive[2].g[top_b] = g_averaged[top_b];\n        massive[3].g[top_b] = g_averaged[top_b];\n\n    }\n\n    if(PP_I == 8)    {\n\n        massive[0].g[top_b] = g_averaged[top_b];\n        massive[1].g[top_b] = g_averaged[top_b];\n        massive[2].g[top_b] = g_averaged[top_b];\n        massive[3].g[top_b] = g_averaged[top_b];\n        massive[4].g[top_b] = g_averaged[top_b];\n        massive[5].g[top_b] = g_averaged[top_b];\n        massive[6].g[top_b] = g_averaged[top_b];\n        massive[7].g[top_b] = g_averaged[top_b];\n\n    }\n\n    if(PP_I == 16)    {\n\n        massive[0].g[top_b] = g_averaged[top_b];\n        massive[1].g[top_b] = g_averaged[top_b];\n        massive[2].g[top_b] = g_averaged[top_b];\n        massive[3].g[top_b] = g_averaged[top_b];\n        massive[4].g[top_b] = g_averaged[top_b];\n        massive[5].g[top_b] = g_averaged[top_b];\n        massive[6].g[top_b] = g_averaged[top_b];\n        massive[7].g[top_b] = g_averaged[top_b];\n        massive[8].g[top_b] = g_averaged[top_b];\n        massive[9].g[top_b] = g_averaged[top_b];\n        massive[10].g[top_b] = g_averaged[top_b];\n        massive[11].g[top_b] = g_averaged[top_b];\n        massive[12].g[top_b] = g_averaged[top_b];\n        massive[13].g[top_b] = g_averaged[top_b];\n        massive[14].g[top_b] = g_averaged[top_b];\n        massive[15].g[top_b] = g_averaged[top_b];\n\n    }\n\n    std::cout << \"min_in_g[E] = \" << min_in_ge << std::endl;\n\n    // -------------- FOR READISTRIBUTED G[E] -----------------\n    // for(int i = 0; i < top_b; i++)  {\n    //     if(hist_averaged[i]!=0)\n    //     g_normalized[i] = g_averaged[i] - min_in_ge;\n    // }\n    // -------------- FOR READISTRIBUTED G[E] -----------------\n\n    // -------------- FOR AVERAGED G[E] -----------------    \n    // for(int i = 0; i < top_b; i++)  {\n        // if(hist_averaged[i]!=0)\n    // }\n    // -------------- FOR AVERAGED G[E] ----------------- \n\n    for(int i = 0; i <= top_b; i++)  {\n        \n        if(i%2 == 0 && i > 2)   {\n            g_normalized[i] = g_averaged[i] - min_in_ge;\n        }\n        // g_averaged[i]/=div_averaging[i];\n        // if(g_averaged[i] > 1.0)\n        // if(L == 8)  {\n            // if(massive[0].hist[i]!=0 || massive[ 1].hist[i]!=0)\n            if(i%2 == 0 && i > 2)   {\n            std::cout << std::fixed << \"g[\" << i << \"]=\" << g_averaged[i] \\\n                      << \":\\t\" << massive[0].g[i] << \"\\t\" << massive[1].g[i] << \"\\t\" \\\n                      << g_normalized[i] << std::endl;\n                  // << \"\\t\" << massive[0].g[i] - massive[0].g[4] << \"\\t\" \\\n                  // << massive[1].g[i] - massive[1].g[20] << \"\\t\" \\\n    \n            }\n        // }\n\n    }  \n\n    std::cout << \"End Averaging of G.\" << std::endl;\n\n    MakeScriptsForAnimation(\"G\"); // Для G[]\n    MakeScriptsForAnimation(\"H\"); // Для Hist[]\n\n    double EE, EE2, GE, Ut, Ft, St, Ct, lambdatemp, lambda;\n\n    std::ofstream out_f_td, out_f_ds, plot_f, script_f, time_f;\n\n    char * filename_out_td = new char [100];\n    char * filename_out_ds = new char [100];\n\n    ss.str(\"\");\n    ss << \"results/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"_MAXMCS=\" << MAX_MCS_COUNT << \".dat\";\n\n    strcpy(filename_out_td ,ss.str().c_str());\n\n    out_f_td.open(filename_out_td);\n    if(!out_f_td) std::cout << \"Cannot open \" << filename_out_td << \".Check permissions or free space\";\n    out_f_td << \"T\\tUt\\tFt\\tSt\\tCt\\n\";\n\n    ss.str(\"\");\n    ss << \"results/DensityStat_L=\" << L << \"_PP=\" << PP_I << \"_MAXMCS=\" << MAX_MCS_COUNT << \".dat\";\n\n    strcpy(filename_out_ds, ss.str().c_str());\n\n    out_f_ds.open(filename_out_ds, std::ios::out);\n    if(!out_f_ds) std::cout << \"Cannot open \" << filename_out_ds << \".Check permissions or free space\";\n    out_f_ds << \"i\\tE(i)\\tg[i]\\n\";\n\n    std::cout << \"Begin estimation for T...\" << std::endl; \n    // TEST\n    // for(int i = 0; i < top_b; i++)  {\n\n    //     std::cout << i << \":\" << g_averaged[i] << std::endl;\n\n    // }\n\n    for(double T = 0.01; T <= 8; T += 0.01)  {\n\n        EE = 0;\n        EE2 = 0;\n        GE = 0;\n\n        lambda = 0;\n        lambdatemp = 0;\n\n        for(int i = 0; i < top_b; i++)  {\n            // if((i!=0) && i%2 == 0 && (i!=L*L-1) && g_averaged[i]==g_averaged[i])    {\n            if(i%2 == 0 && (i!=L*L-1))    {\n                lambdatemp = g_averaged[i] - energy(i)/T;\n                if(lambdatemp > lambda) lambda = lambdatemp;\n            }\n        }\n\n        for(int i = 0; i < top_b; i++) {\n            if(i != 1 && i%2 == 0 && (i!=L*L-1))    {\n                EE += energy(i)*exp(g_averaged[i]-(energy(i))/T-lambda);\n                EE2 += energy(i)*energy(i)*exp(g_averaged[i]-(energy(i))/T-lambda);\n                GE += exp(g_averaged[i]-energy(i)/T-lambda);\n            }\n        }\n\n        Ut = EE/GE;\n        Ft = -T*lambda-(T)*log(GE);\n        St = (Ut-Ft)/T;\n        Ct = ((EE2/GE)-(Ut*Ut))/(T*T);\n\n        // if((Ut==Ut)==true&&(Ft==Ft)==true&&(St==St)==true&&(Ct==Ct)==true) // Не пишем NaN \n        out_f_td << std::fixed << std::setprecision(8) << T << \"\\t\" << Ut/(L*L) << \"\\t\" << Ft/(L*L) << \"\\t\" << St/(L*L) << \"\\t\" << Ct/(L*L) << \"\\n\";\n\n    }\n\n    for(int i = 0; i <= top_b; i++)  {\n        if((i!=2*(L*L)-1) && i%2==0 && i > 4)    {\n            if((g_normalized[i]) >= 0 && (g_normalized[i])==(g_normalized[i]))\n            out_f_ds << std::fixed << std::setprecision(6) << i << \"\\t\" << energy(i) << \"\\t\" << g_normalized[i] << \"\\n\";\n        }\n    }\n\n    ss.str(\"\");\n    ss << \"temp/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I;\n\n    boost::filesystem::create_directories(ss.str().c_str());\n    \n    ss.str(\"\");\n    ss << \"temp/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/Ut.plot\";\n    plot_f.open(ss.str().c_str());\n\n    plot_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"graph/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/Ut.jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xlabel \\\"T\\\"\\n\" << \\\n                 \"set ylabel \\\"Ut\\\"\\n\" << \\\n                 \"plot \\\"\" << filename_out_td << \"\\\" using 1:2 title \\\"landau-wang-omp-\" << L << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n    plot_f.close();\n\n    ss.str(\"\");\n    ss << \"temp/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/Ft.plot\";\n    plot_f.open(ss.str().c_str());\n\n    plot_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"graph/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/Ft.jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xlabel \\\"T\\\"\\n\" << \\\n                 \"set ylabel \\\"Ft\\\"\\n\" << \\\n                 \"plot \\\"\" << filename_out_td << \"\\\" using 1:3 title \\\"landau-wang-omp-\" << L << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n    plot_f.close();\n\n    ss.str(\"\");\n    ss << \"temp/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/St.plot\";\n    plot_f.open(ss.str().c_str());\n\n    plot_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"graph/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I <<  \"/St.jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xlabel \\\"T\\\"\\n\" << \\\n                 \"set ylabel \\\"St\\\"\\n\" << \\\n                 \"plot \\\"\" << filename_out_td << \"\\\" using 1:4 title \\\"landau-wang-omp-\" << L << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n    plot_f.close();\n\n    ss.str(\"\");\n    ss << \"temp/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/Ct.plot\";\n    plot_f.open(ss.str().c_str());\n\n    plot_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"graph/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/Ct.jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xlabel \\\"T\\\"\\n\" << \\\n                 \"set ylabel \\\"Ct\\\"\\n\" << \\\n                 \"plot \\\"\" << filename_out_td << \"\\\" using 1:5 title \\\"landau-wang-omp-\" << L << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n    plot_f.close();\n\n    ss.str(\"\");\n    ss << \"temp/DensityStat_L=\" << L << \"_PP=\" << PP_I;\n\n    boost::filesystem::create_directories(ss.str().c_str());\n\n    ss.str(\"\");\n    ss << \"temp/DensityStat_L=\" << L << \"_PP=\" << PP_I << \"/Ei.plot\";\n    plot_f.open(ss.str().c_str());\n\n    plot_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"graph/DensityStat_L=\" << L << \"_PP=\" << PP_I << \"/Ei.jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xlabel \\\"i\\\"\\n\" << \\\n                 \"set ylabel \\\"E(i)\\\"\\n\" << \\\n                 \"plot \\\"\" << filename_out_ds << \"\\\" using 1:2 title \\\"landau-wang-omp-\" << L << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n    plot_f.close();   \n\n    ss.str(\"\");\n    ss << \"temp/DensityStat_L=\" << L << \"_PP=\" << PP_I << \"/gi.plot\";\n    plot_f.open(ss.str().c_str());\n\n    plot_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n                 \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n                 \"set output \\\"graph/DensityStat_L=\" << L << \"_PP=\" << PP_I << \"/gi.jpg\\\"\\n\" << \\\n                 \"set grid x y\\n\" << \\\n                 \"set xlabel \\\"i\\\"\\n\" << \\\n                 \"set ylabel \\\"g(i)\\\"\\n\" << \\\n                 \"plot \\\"\" << filename_out_ds << \"\\\" using 1:3 title \\\"landau-wang-omp-\" << L << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n    plot_f.close();  \n\n    // ss.str(\"\");\n    // ss << \"temp/DensityStat_L=\" << L << \"/Hi.plot\";\n    // plot_f.open(ss.str().c_str());\n\n    // plot_f << \"#!/usr/bin/gnuplot -persist\\n\" << \\\n    //              \"set terminal jpeg font arial 12 size 800,600\\n\" << \\\n    //              \"set output \\\"graph/DensityStat_L=\" << L << \"/Hi.jpg\\\"\\n\" << \\\n    //              \"set grid x y\\n\" << \\\n    //              \"set yrange [0:10000000]\\n\" << \\\n    //              \"set xlabel \\\"i\\\"\\n\" << \\\n    //              \"set ylabel \\\"H(i)\\\"\\n\" << \\\n    //              \"plot \\\"\" << filename_out_ds << \"\\\" using 1:4 title \\\"landau-wang-\" << L << \"\\\" with lines lt rgb \\\"red\\\"\";\n\n    // plot_f.close();\n\n    ss.str(\"\");\n    ss << \"graph/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I;\n\n    boost::filesystem::create_directories(ss.str().c_str());\n\n    ss.str(\"\");\n    ss << \"graph/DensityStat_L=\" << L << \"_PP=\" << PP_I;\n\n    boost::filesystem::create_directories(ss.str().c_str());\n\n    ss.str(\"\");\n    ss << \"plot_graph_L=\" << L << \"_PP=\" << PP_I << \".sh\";\n\n    script_f.open(ss.str().c_str());\n\n    ss.str(\"\");\n    ss << \"#!/bin/bash\\n\";\n    ss << \"gnuplot temp/TermodinamicalStat_L=\" << L << \"_PP=\" << PP_I << \"/*.plot\\n\";\n    ss << \"gnuplot temp/DensityStat_L=\" << L << \"_PP=\" << PP_I << \"/*.plot\\n\";\n\n    script_f << ss.str();\n\n    // ss.str(\"\");\n    // ss << \"sh plot_graph_L=\" << L << \".sh\";\n\n    // chdir(\".\");\n    // system(ss.str().c_str());\n\n    time_e = omp_get_wtime();\n\n    std::cout << \"Time: \" << time_e - time_b << \"'s\" << std::endl;\n\n    ss.str(\"\");\n    ss << \"Time-\" << L << \"-PP-\" << PP_I << \"_MAXMCS=\" << MAX_MCS_COUNT;\n\n    time_f.open(ss.str().c_str());\n\n    time_f << time_e - time_b << \"'s\" << std::endl;\n\n    time_f.close();\n\n    out_f_td.close();\n    out_f_ds.close();\n\n    delete [] filename_out_td;\n    delete [] filename_out_ds;\n\n    delete [] E_min;\n    delete [] E_max;\n    delete [] b_last;\n\n}\n\nint MakeScriptsForAnimation(std::string str)   {\n\n    // Функция создания скриптов для анимации для плотности энергетических состояний\n\n    // Функция создания скриптов для создания анимации для гистограммы\n\n    std::stringstream ss;\n    std::ofstream graph_sh;\n\n    if(str == \"G\")  {\n        \n        for(int intervals = 0; intervals < PP_I; intervals++)  {\n    \n            ss.str(\"\");\n            ss << \"plot_test_g_graph-L=\" << L << \"_PP=\" << PP_I << \"-\" << intervals << \".sh\";\n                \n            graph_sh.open(ss.str().c_str());\n            graph_sh << \"#!/bin/bash\\n\" <<  \"gnuplot test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-\" << intervals << \"/temp/*.plot\\n\";\n            graph_sh <<  \"convert -delay 10 -loop 0 test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-\" << intervals << \\\n                            \"/graphs/{1..20}.jpg animate-DoS-L=\" << L << \"_PP=\" << PP_I <<\"-\" << intervals << \".gif\\n\";\n            graph_sh.close();\n    \n        }\n    \n        ss.str(\"\");\n        ss << \"plot_test_g_graph-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \".sh\";\n    \n        graph_sh.open(ss.str().c_str());\n        graph_sh << \"#!/bin/bash\\n\" <<  \"gnuplot test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \"/temp/*.plot\\n\";\n        graph_sh <<  \"convert -delay 10 -loop 0 test_g/DoS-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \\\n                        \"/graphs/{1..20}.jpg animate-DoS-L=\" << L << \"_PP=\" << PP_I <<\"-AV\" << \".gif\\n\";\n        graph_sh.close();\n    }\n\n    if(str == \"H\")  {\n\n        for(int intervals = 0; intervals < PP_I; intervals++)  {\n\n            ss.str(\"\");\n            ss << \"plot_test_hist_graph-L=\" << L << \"_PP=\" << PP_I << \"-\" << intervals << \".sh\";\n        \n            graph_sh.open(ss.str().c_str());\n            graph_sh << \"#!/bin/bash\\n\" <<  \"gnuplot test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-\" << intervals << \"/temp/*.plot\\n\";\n            graph_sh <<  \"convert -delay 10 -loop 0 test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-\" << intervals << \\\n                    \"/graphs/{1..200}.jpg animate-Hist-L=\" << L << \"_PP=\" << PP_I << \"-\" << intervals << \".gif\\n\";\n            graph_sh.close();\n\n        }\n\n        ss.str(\"\");\n        ss << \"plot_test_hist_graph-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \".sh\";\n    \n        graph_sh.open(ss.str().c_str());\n        graph_sh << \"#!/bin/bash\\n\" <<  \"gnuplot test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \"/temp/*.plot\\n\";\n        graph_sh <<  \"convert -delay 10 -loop 0 test_g/Hist-L=\" << L << \"_PP=\" << PP_I << \"-AV\" << \\\n                            \"/graphs/{1..200}.jpg animate-Hist-L=\" << L << \"_PP=\" << PP_I <<\"-AV\" << \".gif\\n\";\n        graph_sh.close();\n\n    }\n\n    return 0;\n\n}\n\n\n// inline int neighbour_spins(int **spin, int i, int j)    {\n\n//     int result;\n\n//     if(i==0)    result=spin[L-1][j];    \n//     else        result=spin[i-1][j];\n//     if(i==L-1)  result+=spin[0][j];\n//     else        result+=spin[i+1][j];\n//     if(j==0)    result+=spin[i][L-1];\n//     else        result+=spin[i][j-1];\n//     if(j==L-1)  result+=spin[i][0];\n//     else        result+=spin[i][j+1];\n\n//     return result;\n// }\n",
			"file": "landau-wang-omp-3d.cpp",
			"file_size": 66921,
			"file_write_time": 131099630938914849,
			"settings":
			{
				"buffer_size": 65526,
				"line_ending": "Unix"
			}
		},
		{
			"file": "landau-wang-omp-2d.cpp",
			"settings":
			{
				"buffer_size": 64947,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/nlare/_code/tex-guide_systemd/document.tex",
			"settings":
			{
				"buffer_size": 1043,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/nlare/_code/tex-Landau-Wang-presentation-09.12.15/presentation.tex",
			"settings":
			{
				"buffer_size": 10528,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/nlare/_code/tex-guide_hotkeys/document.tex",
			"settings":
			{
				"buffer_size": 1564,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Makefile",
			"settings":
			{
				"buffer_size": 1053,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/User/My-C++.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/User/JavaC-jsoup.sublime-build",
					""
				],
				[
					"Packages/User/My-C++.sublime-build",
					""
				],
				[
					"Packages/User/My-C++.sublime-build",
					"Run"
				],
				[
					"Packages/User/commit-nas.sublime-build",
					""
				]
			],
			[
				"Packages/User/My-C++.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					""
				],
				[
					"Packages/User/JavaC-jsoup.sublime-build",
					""
				],
				[
					"Packages/User/commit-nas.sublime-build",
					""
				]
			],
			[
				"Packages/LaTeXTools/LaTeX.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/User/My-C++.sublime-build",
					""
				],
				[
					"Packages/User/My-C++.sublime-build",
					"Run"
				]
			],
			[
				"Packages/User/My-C++.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 400.0,
		"last_filter": "pa",
		"selected_items":
		[
			[
				"pa",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: List Packages"
			],
			[
				"bro",
				"Preferences: Browse Packages"
			]
		],
		"width": 820.0
	},
	"console":
	{
		"height": 113.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/nlare/_code/cpp-Landau-Wang-omp-averaged"
	],
	"file_history":
	[
		"/home/nlare/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/nlare/_code/cpp-Landau-Wang/landau-wang.cpp",
		"/home/nlare/_code/tex-Landau-Wang-presentation-02.06.16/presentation.tex",
		"/home/nlare/_code/tex-Landau-Wang-Report/document.tex",
		"/home/nlare/_code/tex-Alcom-pwd/document.tex",
		"/home/nlare/_code/tex-Alcom-quests/document.tex",
		"/home/nlare/_code/java-YouTubeUploader/YouTubeUploader.sublime-project",
		"/home/nlare/_code/tex-English-Q&A/Martyn-Q&A.tex",
		"/home/nlare/_code/java-YouTubeUploader/com/uploader/AppGui.java",
		"/home/nlare/_code/java-YouTubeUploader/YouTubeUploader.sublime-workspace",
		"/home/nlare/_code/tex-urxvt-tricks/document.tex",
		"/home/nlare/_code/tex-guide_git_client_server/document.tex",
		"/home/nlare/_code/tex-guide_rtorrent+rutorrent/document.tex",
		"/home/nlare/_code/tex-guide_rsync/document.tex",
		"/home/nlare/_code/cpp-Landau-Wang-omp-averaged/landau-wang-omp-test.cpp",
		"/home/nlare/_code/tex-ClamAV/document.tex",
		"/home/nlare/_code/tex-guide_NFS_commands/document.tex",
		"/home/nlare/data/downloads/Links.txt",
		"/home/nlare/_scripts/convert-wav2mp3.sh",
		"/home/nlare/_record/010101001.txt",
		"/home/nlare/_record/110101111110111001.txt",
		"/home/nlare/_record/101010101010011.txt",
		"/home/nlare/_record/00010010111.txt",
		"/home/nlare/_record/00010010111 (1).txt"
	],
	"find":
	{
		"height": 38.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"IS ",
			"E_min",
			"Time",
			"defect",
			"min_hist",
			"DEBUG_G",
			"it_count_g",
			"rank",
			"it_count_g",
			"if(massive",
			"massive",
			"if( massive",
			"if(massive",
			"if(i",
			"G[]",
			"G[?}",
			"graphs",
			"pp_i",
			"plot_test_",
			"plot_graph_",
			"graph_sh_g",
			"check1"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"pp_i",
			"rank"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "landau-wang-omp-test.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64947,
						"regions":
						{
						},
						"selection":
						[
							[
								5313,
								5313
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2280.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "landau-wang-omp-3d.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 65526,
						"regions":
						{
						},
						"selection":
						[
							[
								12793,
								12793
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4555.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "landau-wang-omp-2d.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64947,
						"regions":
						{
						},
						"selection":
						[
							[
								5313,
								5313
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2730.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/home/nlare/_code/tex-guide_systemd/document.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1043,
						"regions":
						{
						},
						"selection":
						[
							[
								925,
								925
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/home/nlare/_code/tex-Landau-Wang-presentation-09.12.15/presentation.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10528,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 91.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/home/nlare/_code/tex-guide_hotkeys/document.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1564,
						"regions":
						{
						},
						"selection":
						[
							[
								1469,
								1469
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 130.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "Makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1053,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 21.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 134.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": ".project.sublime-project",
	"replace":
	{
		"height": 72.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 251.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
